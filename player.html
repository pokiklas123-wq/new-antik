<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ¬ Ù…Ø´ØºÙ„ Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø±</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', sans-serif;
        }
        
        #videoContainer {
            width: 100vw;
            height: 100vh;
            background: #000;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        /* Ø·Ø¨Ù‚Ø© Ø§Ù„ØªØ­ÙƒÙ…Ø§Øª */
        #controlsOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
            pointer-events: none;
        }
        
        #controlsOverlay.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* Ø²Ø± ÙƒØªÙ… Ø§Ù„ØµÙˆØª ÙÙ‚Ø· */
        .control-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
            width: 70px;
            height: 70px;
            font-size: 30px;
        }
        
        .control-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.2);
        }

    </style>
</head>
<body>
    <div id="videoContainer">
        <video id="remoteVideo" autoplay playsinline></video>
        
        <!-- Ø·Ø¨Ù‚Ø© Ø§Ù„ØªØ­ÙƒÙ…Ø§Øª ÙÙŠ Ø§Ù„ÙˆØ³Ø· -->
        <div id="controlsOverlay">
            <!-- Ø²Ø± ÙƒØªÙ… Ø§Ù„ØµÙˆØª ÙÙ‚Ø· -->
            <button id="muteBtn" class="control-btn">
                <i class="fas fa-volume-up"></i>
            </button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let peerConnection;
        let currentRoomId = null;
        let currentUserName = null;
        let controlsTimeout;
        
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478' }
            ]
        };

        // === Ø¹Ù†Ø§ØµØ± DOM ===
        const videoContainer = document.getElementById('videoContainer');
        const video = document.getElementById('remoteVideo');
        const controlsOverlay = document.getElementById('controlsOverlay');
        const muteBtn = document.getElementById('muteBtn');

        // === ÙˆØ¸Ø§Ø¦Ù Ø§Ù„ØªØ­ÙƒÙ… ===
        
        // Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØªØ­ÙƒÙ…Ø§Øª
        function toggleControls(e) {
            // Ù…Ù†Ø¹ Ø§Ù„Ø§Ø®ØªÙØ§Ø¡ Ø¥Ø°Ø§ Ø¶ØºØ·Ù†Ø§ Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„ØªØ­ÙƒÙ…
            if (e.target.closest('.control-btn')) return;

            if (controlsOverlay.classList.contains('show')) {
                hideControls();
            } else {
                showControls();
            }
        }

        function showControls() {
            controlsOverlay.classList.add('show');
            resetHideTimer();
        }

        function hideControls() {
            controlsOverlay.classList.remove('show');
            clearTimeout(controlsTimeout);
        }

        function resetHideTimer() {
            clearTimeout(controlsTimeout);
            // Ø¥Ø®ÙØ§Ø¡ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¨Ø¹Ø¯ 3 Ø«ÙˆØ§Ù†ÙŠ
            controlsTimeout = setTimeout(hideControls, 3000);
        }
        
        // ÙƒØªÙ… Ø§Ù„ØµÙˆØª
        function toggleMute() {
            video.muted = !video.muted;
            updateMuteIcon();
            resetHideTimer();
        }

        function updateMuteIcon() {
            if (video.muted) {
                muteBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
                muteBtn.style.color = '#ff4444'; // Ù„ÙˆÙ† Ø£Ø­Ù…Ø± Ø¹Ù†Ø¯ Ø§Ù„ÙƒØªÙ…
            } else {
                muteBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
                muteBtn.style.color = 'white';
            }
        }

        // === Ù…Ø³ØªÙ…Ø¹Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ===
        
        // Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© Ù„Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØªØ­ÙƒÙ…Ø§Øª
        videoContainer.addEventListener('click', toggleControls);
        videoContainer.addEventListener('touchstart', () => {
             // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù„Ù„Ù…Ø³
             if (!controlsOverlay.classList.contains('show')) showControls();
        }, {passive: true});

        // Ø²Ø± ÙƒØªÙ… Ø§Ù„ØµÙˆØª ÙÙ‚Ø·
        muteBtn.addEventListener('click', toggleMute);

        // === WebRTC Code (ÙƒÙ…Ø§ Ù‡Ùˆ Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±) ===
        function getParamsFromURL() {
            try {
                const url = new URL(window.location.href);
                const roomParam = url.searchParams.get('room');
                if (!roomParam) throw new Error('no-room');
                const parts = roomParam.split('/');
                if (parts.length < 2 || !parts[0] || !parts[1]) throw new Error('invalid-format');
                return { roomId: parts[0], userName: decodeURIComponent(parts[1]) };
            } catch (error) {
                redirectToError(error.message);
                return null;
            }
        }
        
        function redirectToError(errorType) {
            const url = new URL(window.location.href);
            const roomParam = url.searchParams.get('room') || '';
            window.location.href = `https://new-antik-p2p-20.onrender.com/error.html?room=${roomParam}&error=${errorType}`;
        }
        
        function connectToStream() {
            const params = getParamsFromURL();
            if (!params) return;
            currentRoomId = params.roomId;
            currentUserName = params.userName;
            socket.emit('join-room', { roomId: currentRoomId, userName: currentUserName });
            showControls(); // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ…Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø¯Ø¡
        }
        
        socket.on('joined-room', () => console.log('âœ… ØªÙ… Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ù„ØºØ±ÙØ©'));
        
        socket.on('offer', async (data) => {
            if (!peerConnection) createPeerConnection(data.from);
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                socket.emit('answer', { to: data.from, roomId: currentRoomId, sdp: answer });
            } catch (error) {
                redirectToError('connection-failed');
            }
        });
        
        socket.on('webrtc-signal', async (data) => {
            if (!peerConnection && data.type === 'offer') createPeerConnection(data.from);
            try {
                if (data.type === 'offer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.signal));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    socket.emit('webrtc-signal', { to: data.from, type: 'answer', signal: answer });
                } else if (data.type === 'candidate' && peerConnection) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.signal));
                }
            } catch (error) {
                redirectToError('connection-failed');
            }
        });
        
        socket.on('ice-candidate', async (data) => {
            if (peerConnection && data.candidate) {
                try { await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate)); } catch (e) {}
            }
        });
        
        function createPeerConnection(broadcasterId) {
            peerConnection = new RTCPeerConnection(rtcConfig);
            peerConnection.ontrack = (event) => {
                video.srcObject = event.streams[0];
                video.play().then(() => {
                    showControls();
                }).catch(() => {
                    showControls();
                });
            };
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) socket.emit('ice-candidate', { roomId: currentRoomId, candidate: event.candidate });
            };
            peerConnection.onconnectionstatechange = () => {
                if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    setTimeout(() => redirectToError('stream-ended'), 2000);
                }
            };
        }
        
        socket.on('broadcast-ended', () => redirectToError('stream-ended'));
        socket.on('room-not-found', () => redirectToError('room-not-found'));
        socket.on('error', () => redirectToError('server-error'));
        socket.on("connect_error", () => redirectToError('server-unreachable'));
        
        setTimeout(() => {
            if (!video.srcObject) redirectToError('stream-ended');
        }, 30000);
        
        window.onload = connectToStream;
    </script>
</body>
</html>
